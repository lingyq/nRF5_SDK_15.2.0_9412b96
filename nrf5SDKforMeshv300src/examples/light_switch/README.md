# Light switch demo

@note This example is not supported by the nRF52810 Series.

## Purpose

This demo project consists of three sub examples:
- light switch server (with GATT proxy support),
- light switch client (with GATT proxy support),
- provisioner example.

The example demonstrates the mesh eco system containing devices acting in two roles, a Provisioner role, and
a Node role. In addition, it demonstrates how to use custom models by using
the [Generic OnOff model](@ref GENERIC_ONOFF_MODEL) in
a real application.


## Getting started

### Hardware requirements

See [Compatibility](@ref md_doc_introduction_mesh_compatibility) for the supported boards.

1. One development board for a client.
2. One development board for the provisioner or @link_nrf_mesh_app (@link_nrf_mesh_app_ios or @link_nrf_mesh_app_android).
3. One or more development boards for the servers.
  If you have more than thirty boards for the servers, set `SERVER_NODE_COUNT` (in `light_switch_example_common.h`)
  to the number of boards available and rebuild the provisioner example.

### Running the demo

To build the examples, follow the instructions in
[Building the Mesh Stack](@ref md_doc_getting_started_how_to_build). 
For commands required to program a device using `nrfjprog`, see the [Running examples using nrfjprog](@ref how_to_run_examples_nrfjprog) section on the @ref md_doc_getting_started_how_to_run_examples page.

To run the examples, the boards must be provisioned first. It can be done using either
[the development board](@ref light_switch_prov_prov_example) or
[nRF Mesh mobile app](@ref light_switch_prov_nrf_mesh).

#### Provisioning using the development board @anchor light_switch_prov_prov_example

To complete the provisioning process:

1. Erase the device flash of your development boards and program the SoftDevice.
2. Flash the provisioner and the client firmware on individual boards and the server firmware on other boards.
3. After a reset, press Button 1 on the provisioner to start the provisioning and the configuration of the
   devices. The provisioner first provisions and configures the client and then moves on to provision and configure the servers, one by one.
4. Use the [RTT](@ref segger-rtt) viewer to view the RTT output generated by the provisioner.

The provisioner prints details about the provisioning and the configuration process in the RTT log.
When provisioner is scanning and provisioning a device, LED 1 on the Provisioner board is turned ON.
When configuration procedure is underway, LED 2 on the provisioner board is turned ON.

The provisioner configures the client model instances on the client board. The client example is
configured as follows:
- The Button 1 on the client board turns ON LED 1 on the servers with Odd addresses.
- The Button 2 on the client board turns OFF LED 1 on the servers with Odd addresses.
- The Button 3 on the client board turns ON LED 1 on the servers with Even addresses.
- The Button 4 on the client board turns OFF LED 1 on the servers with Even addresses.

If the provisioner encounters an error during the provisioning or configuration process for a certain node,
you can reset the provisioner to restart this process for that node.

#### Provisioning using nRF Mesh mobile app @anchor light_switch_prov_nrf_mesh

To provision using the mobile app, both on iOS and Android:

1. Erase the device flash of your development boards and program the SoftDevice.
2. Flash the client and server firmwares.
3. Download @link_nrf_mesh_app (@link_nrf_mesh_app_ios or @link_nrf_mesh_app_android).
4. Provision the nodes. The client board is `nRF5x Mesh Switch`,
the server board is `nRF5x Mesh Light`.
5. Bind the Generic OnOff client and server model instances on the nodes with the same app key.
6. Set the publish address of the first Generic OnOff client model instance on the client example to
the unicast address of any server node. This configures the client example as follows:
- The Button 1 on the client board turns ON LED 1 on the corresponding server board.
- The Button 2 on the client board turns OFF LED 1 on the corresponding server board.

#### Testing

Once provisioning and configuration of the client node and at least one of the server nodes is completed,
you can press buttons on the client to see the LEDs getting toggled on the associated servers.

If an RTT terminal is available and connected to the client, sending
the ASCII numbers `0`--`3` will have the same effect as pressing the buttons.

You can also press Button 1 on the servers to locally toggle the state of their LED 1,
and the status reflecting this state will be sent to the client board. You can see the status printed in
the RTT log of the client board.

If any of the devices are powered off and back on, they will remember their configuration
in flash and rejoin the network. More information about the flash manager can be found
in the [flash manager documentation](@ref md_doc_libraries_flash_manager).

## Details

### Mesh provisioner

The *provisoner* provisions and configures the nodes to setup a demo mesh network.
It is implemented as a multi-layered state machine due to the asynchronous nature of the provisioning and configuration process.

The provisioner first provisions and configures a client device with a known UUID.
After this it moves on to provision and configure the server devices.

The following diagram shows the typical state transitions of the provisioner while provisioning and configuring light switch servers.

![Light switch client state diagram](img/light_switch_client_state_diagram.svg "Light switch client state diagram")

For more information on how a provisioner works, see the [Mesh provisioning Guide](@ref md_doc_getting_started_provisioning).

### Light switch client @anchor light_switch_demo_client

The *Light switch client* has a provisionee role in the network.
The client has four buttons to control the state of LED 1 on servers.
It instantiates two instances of Generic OnOff Client model.
It can either be provisioned and configured by the provisioner device or
by a GATT-based provisioner. The provisioner configures this client model
instances to communicate with servers.

### Light switch server @anchor light_switch_demo_server

The *Light switch server* has a provisionee role in the network. It instantiates one instance
of the Generic OnOff server model to control the state of LED 1. It can either be provisioned
and configured by the provisioner device or by a GATT-based provisioner.
The provisioner configures this server model instance to communicate with
the client model on the client board and to publish a message when value of the OnOff state changes.

![State diagram for the Light switch server](img/light_switch_server_state_diagram.svg)

After provisioning, the proxy server application starts advertising a connectable proxy
beacon, which a Proxy Client can connect to in order to interact with the mesh.
The Proxy Client acts like any other mesh device, but sends all of its mesh communication
over a BLE connection to a Proxy Server, which relays it into the mesh.

As proxy is only supported on the nRF52, cmake will not generate the proxy server example for nRF51.

### GATT Proxy

Both the Light switch server and Light switch client examples support
provisioning over GATT (PB-GATT) and Proxy Server.

@note The *Proxy Client* role is **not** supported.

Read more about the Proxy feature in @ref md_doc_getting_started_gatt_proxy.

### Generic OnOff client/server model

The Generic OnOff Client/Server is used for manipulating an
on/off state. Note that when the server has a publish address set (as in this example),
the server will publish any operation of its state change to its publish address.

More information about the Generic OnOff model can be found in the
[Generic OnOff model documentation](@ref GENERIC_ONOFF_MODEL)
and [Generic OnOff server behaviour documentation](@ref APP_ONOFF).

## Mesh SDK APIs

See the @subpage md_doc_getting_started_how_to_build_your_network
document to get a quick overview of the various SDK APIs.
